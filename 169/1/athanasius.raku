#!/usr/bin/env raku

###############################################################################
=begin comment

Perl Weekly Challenge 169
=========================

TASK #1
-------
*Brilliant Numbers*

Submitted by: Mohammad S Anwar

Write a script to generate first 20 Brilliant Numbers.

    Brilliant numbers are numbers with two prime factors of the same length.

The number should have _exactly_ two prime factors, i.e. it’s the product of
two primes of the same length.

For example,

  24287 = 149 x 163
  24289 = 107 x 227

  Therefore 24287 and 24289 are 2-brilliant numbers.
  These two brilliant numbers happen to be consecutive as there are no even
  brilliant numbers greater than 14.

Output

  4, 6, 9, 10, 14, 15, 21, 25, 35, 49, 121, 143, 169, 187, 209, 221, 247, 253,
  289, 299

=end comment
###############################################################################

#--------------------------------------#
# Copyright © 2022 PerlMonk Athanasius #
#--------------------------------------#

#==============================================================================
=begin comment

Note
----
If an n-brilliant number is defined as a product of n primes of the same length
(i.e., of the same number of digits when represented in base 10), then this
Task is a search for 2-brilliant numbers. [2]

Algorithm
---------
The number of brilliant numbers required is specified in the constant $TARGET.
Although the number is given as 20 in the Task description, I have designed the
solution to accommodate larger numbers by making the generation of primes open-
ended.

Prime numbers are generated by get-primes(), which receives as input the number
of digits required, and returns a sorted list of all the primes with that num-
ber of digits. get-primes() uses a sieve of Eratosthenes, which on subsequent
calls is extended as needed.

The algorithm *constructs* brilliant numbers by producing all possible combina-
tions of prime numbers of a given number of digits. As the brilliant numbers
are produced out-of-order, they must be sorted to produce the required solu-
tion. However, note that when the number of digits per prime number increases,
the smallest new brilliant number is necessarily larger than the previously-
largest one; e.g., 101² > 97². Therefore, when a given number of prime digits
produces a total number of brilliant numbers greater than or equal to $TARGET,
no further generation of brilliant numbers is needed.

Reference
---------
[1] "A078972  Brilliant numbers: semiprimes (products of two primes, A001358)
     whose prime factors have the same number of decimal digits.", OEIS,
     https://oeis.org/A078972
[2]  Dario Alpern, "Brilliant numbers",
     https://www.alpertron.com.ar/BRILLIANT.HTM

=end comment
#==============================================================================

my UInt constant $TARGET = 20;

#==============================================================================
sub MAIN()
#==============================================================================
{
    my UInt %brilliant{UInt};

    loop (my UInt $digits = 1; %brilliant.keys.elems < $TARGET; ++$digits)
    {
        my UInt @primes = get-primes( $digits );

        for @primes -> UInt $p
        {
            for @primes -> UInt $q
            {
                ++%brilliant{ $p * $q };
            }
        }
    }

    my UInt @brilliant = %brilliant.keys.sort;

    "The first %d brilliant numbers:\n%s\n".printf:
        $TARGET, @brilliant[ 0 .. $TARGET - 1 ].join: ', ';
}

#------------------------------------------------------------------------------
# Extensible sieve of Eratosthenes
#
sub get-primes( UInt:D $digits --> Seq:D[UInt:D] )
#------------------------------------------------------------------------------
{
    my    UInt $max-idx  = 10 ** $digits - 1;
    state UInt @sieve    = False, False, |(1 xx ($max-idx - 1));
    my    UInt $orig-end = @sieve.end;
    state Bool $first    = True;

    if $first || $max-idx > $orig-end
    {
        @sieve.push: |(1 xx ($max-idx - $orig-end)) if !$first;  # Extend sieve

        for 0 .. $max-idx.sqrt.Int -> UInt $i
        {
            if @sieve[ $i ]                                      # Prime
            {
                my UInt $start = $first ?? 2 !! (($orig-end + 1) / $i).floor;

                for $start .. ($max-idx / $i).floor -> UInt $j
                {
                    @sieve[ $i * $j ] = 0;                       # Composite
                }
            }
        }

        $first = False;
    }

    # @range contains all integers of the required number of digits:
    # e.g., if $digits = 2 then @range = 10 .. 99

    my UInt @range = 10 ** ($digits - 1) .. $max-idx;

    return @range.grep: { @sieve[ $_ ] };                     # Apply the sieve
}

#------------------------------------------------------------------------------
sub USAGE()
#------------------------------------------------------------------------------
{
    my Str $usage = $*USAGE;

    $usage ~~ s/ ($*PROGRAM-NAME) /raku $0/;

    $usage.put;
}

###############################################################################
