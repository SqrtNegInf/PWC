#!/usr/bin/env perl

use strict;
use warnings;
use English;

################################################################################
# Begin main execution
################################################################################

my @trees;
my $tree;

# Given cases:

# Tree 0:
#     1
#    / \
#   2   3
#  / \
# 4   5

$trees[0] = make_tree_node(1);
$trees[0]{l} = make_tree_node(2);
$trees[0]{r} = make_tree_node(3);
$trees[0]{l}{l} = make_tree_node(4);
$trees[0]{l}{r} = make_tree_node(5);


# Tree 1:
#     1
#    / \
#   2   3
#  /     \
# 4       5
#  \
#   6

$trees[1] = make_tree_node(1);
$trees[1]{l} = make_tree_node(2);
$trees[1]{r} = make_tree_node(3);
$trees[1]{l}{l} = make_tree_node(4);
$trees[1]{r}{r} = make_tree_node(5);
$trees[1]{l}{l}{r} = make_tree_node(6);


# Additional test cases:

# Tree 2:
#   1
#  / \
# 2   3
#      \
#       4

$trees[2] = make_tree_node(1);
$trees[2]{l} = make_tree_node(2);
$trees[2]{r} = make_tree_node(3);
$trees[2]{r}{r} = make_tree_node(4);


print("\n");
for $tree (0 .. $#trees){
    printf(
        "Minimum leaf depth for tree %d is: %d\n",
        $tree,
        minimum_leaf_depth($trees[$tree])
    );
}
print("\n");

exit(0);
################################################################################
# End main execution; subroutines follow
################################################################################



################################################################################
# Determine the minimum depth at which a leaf appears in a tree
# Takes one argument:
# * A ref to the tree to examine, which must consist of nodes of the type
#   generated by make_tree_node()
# Returns:
# * The depth of the leaf closest to the root of the tree
################################################################################
sub minimum_leaf_depth{
    my $tree = shift();

    my $min_leaf_depth = 0;

    _min_leaf_depth_recursor($tree, 1, \$min_leaf_depth);

    return($min_leaf_depth);

}



################################################################################
# Do the actual work of determining the minimum depth at which a leaf appears
# in a tree
# Takes three arguments:
# * A ref to the tree to examine, which must consist of nodes of the type
#   generated by make_tree_node()
# * The depth of this node; this must be 1 when this function is first called
# * A ref to a scalar which will be used to keep track of the minimum depth;
#   this must be set to 0 when this function is first called, and it will
#   contain the minimum depth when that call returns
# Returns no meaningful value
# NOTE: This function should only be called by minimum_leaf_depth(), which does
# some initial setup
################################################################################
sub _min_leaf_depth_recursor{
    my $node = shift();
    my $curr_depth = int(shift());
    my $min_leaf_depth = shift();

    if($$min_leaf_depth && ($curr_depth >= $$min_leaf_depth)){
        # We've seen a leaf before and we're as
        # deep or deeper than that... no point in
        # proceeding further
        return();
    }

    if(!$node->{l} && !$node->{r}){
        # This is a leaf
        if($curr_depth < $min_leaf_depth){
            # And it's the shallowest we've seen
            $$min_leaf_depth = $curr_depth;
        }
        return();
    }

    # This wasn't a leaf- traverse down each
    # defined branch
    $node->{l} && _min_leaf_depth_recursor(
        $node->{l}, $curr_depth + 1, $min_leaf_depth
    );
    $node->{r} && _min_leaf_depth_recursor(
        $node->{r}, $curr_depth + 1, $min_leaf_depth
    );

    return();

}



################################################################################
# Make a node for a binary tree
# Takes one argument:
# * A scalar that represents (or points to) the data (D) to store in this node
# Returns:
# * A binary tree node in the form of a hash ref with the data stored therein,
#   and left/right ref fields set to undef, e.g.:
#   {
#       d => D,
#       l => undef,
#       r => undef
#   }
################################################################################
sub make_tree_node{
    my $n = shift();

    return(
        {
            d => $n,
            l => undef,
            r => undef
        }
    );

}



