#!/usr/bin/env raku

###############################################################################
=begin comment

Perl Weekly Challenge 144
=========================

TASK #2
-------
*Ulam Sequence*

Submitted by: Mohammad S Anwar

You are given two positive numbers, $u and $v.

Write a script to generate Ulam Sequence having at least 10 Ulam numbers where
$u and $v are the first 2 Ulam numbers.

For more information about Ulam Sequence, please checkout the
[ https://en.wikipedia.org/wiki/Ulam_number |website].

    The standard Ulam sequence (the (1, 2)-Ulam sequence) starts with U1 = 1
    and U2 = 2. Then for n > 2, Un is defined to be the smallest integer that
    is the sum of two distinct earlier terms in exactly one way and larger than
    all earlier terms.

Example 1

 Input: $u = 1, $v = 2
 Output: 1, 2, 3, 4, 6, 8, 11, 13, 16, 18

Example 2

 Input: $u = 2, $v = 3
 Output: 2, 3, 5, 7, 8, 9, 13, 14, 18, 19

Example 3

 Input: $u = 2, $v = 5
 Output: 2, 5, 7, 9, 11, 12, 13, 15, 19, 23

=end comment
###############################################################################

#--------------------------------------#
# Copyright Â© 2021 PerlMonk Athanasius #
#--------------------------------------#

#==============================================================================
=begin comment

Algorithm
---------
@ulams is an array containing Ulam numbers in the order of their discovery.
%sums  is a hash matching each sum of two distinct Ulam numbers to a count of
       the number of different ways in which that sum can be produced.

The main loop generates one new Ulam number per iteration, as follows:
    - New sums are generated by adding the latest (i.e. last found) Ulam number
      $last to each of the previously-known Ulam numbers.
    - The next Ulam number is the smallest key in %sums which (1) is greater
      than $last and (2) has a count of 1.

Note that %sums is pruned on each iteration of the main loop by deleting all
the sums less than or equal to $last. This is not strictly necessary (a
different logic could be used), but has two advantages:
    1. It simplifies the logic, as the smallest candidate Ulam number is
       guaranteed to be greater than $last.
    2. It prevents %sums from becoming unnecessarily large in memory. (This is
       not a consideration when $TARGET = 10, but could become significant for
       large values of $TARGET.)

Each Ulam number is displayed as it is found. This allows the user to monitor
progress when using large values of $TARGET.

=end comment
#==============================================================================

subset Pos of Int where * > 0;

my Pos constant $TARGET = 10;

#------------------------------------------------------------------------------
BEGIN
#------------------------------------------------------------------------------
{
    #"\nChallenge 144, Task #2: Ulam Sequence (Raku)\n".put;
}

#==============================================================================
sub MAIN
(
    #Pos:D $u,                             #= A positive integer
    #Pos:D $v where { $v > $u }            #= A positive integer > u
)
#==============================================================================
{
    my $u = 1;
    my $v = 2;
    "Input:  \$u = $u, \$v = $v\nOutput: $u, $v".print;

    my Pos @ulams = $u, $v;
    my Pos $last  = $v;
    my Pos %sums;

    while @ulams.elems < $TARGET
    {
        ++%sums{ $_ + $last } for @ulams[ 0 .. @ulams.end - 1 ];

        $last = %sums.keys.grep( { %sums{ $_ } == 1 } ).map( { .Int } ).min;

        @ulams.push: $last;
        ", $last".print;

        $_ <= $last && (%sums{ $_ }:delete) for %sums.keys;
    }

    put();
}

#------------------------------------------------------------------------------
sub USAGE()
#------------------------------------------------------------------------------
{
    my Str $usage = $*USAGE;

    $usage ~~ s/ ($*PROGRAM-NAME) /raku $0/;
    $usage.put;
}

##############################################################################
